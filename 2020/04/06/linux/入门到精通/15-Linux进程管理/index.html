<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="李健博">
  <meta name="keyword" content="hexo-theme">
  
    <link rel="shortcut icon" href="/css/images/logo.png">
  
  <title>
    
      15-linux的进程管理介绍 | Mr.Lee-李健博的博客
    
  </title>
  <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/css/plugins/gitment.css">

  
  <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.js"></script>
  
    
<script src="/js/qrious.js"></script>

  
  
    
<script src="/js/gitment.js"></script>

  
  

  
<meta name="generator" content="Hexo 6.1.0"></head>
<div class="wechat-share">
  <img src="/css/images/logo.png" />
</div>

  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>Mr.Lee-李健博的博客</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">主页</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/tags/" class="item-link">标签</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">归档</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/about/" class="item-link">关于我</a>
          
        </li>
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">主页</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/tags/" class="menu-link">标签</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">归档</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/about/" class="menu-link">关于我</a>
            
          </li>
        
      </ul>
    </div>
  </div>
</header>

    <div id="article-banner">
  <h2>15-linux的进程管理介绍</h2>



  <p class="post-date">2020-04-06</p>
    <!-- 不蒜子统计 -->
    <span id="busuanzi_container_page_pv" style='display:none' class="">
        <i class="icon-smile icon"></i> 阅读数：<span id="busuanzi_value_page_pv"></span>次
    </span>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h2><h3 id="1-什么是进程"><a href="#1-什么是进程" class="headerlink" title="1.什么是进程"></a>1.什么是进程</h3><p>比如: 开发写的代码我们称为程序，那么将开发的代码运行起来。我们称为进程。<br>总结一句话就是: 当我们运行一个程序，那么我们将运行的程序叫进程。<br>PS1: 当程序运行为进程后，系统会为该进程分配内存，以及进程运行的身份和权限。<br>PS2: 在进程运行的过程中，系统会有各种指标来表示当前运行的状态。</p>
<h3 id="2-程序和进程的区别"><a href="#2-程序和进程的区别" class="headerlink" title="2.程序和进程的区别"></a>2.程序和进程的区别</h3><p>1.程序是数据和指令的集合，是一个静态的概念。比如&#x2F;bin&#x2F;ls、&#x2F;bin&#x2F;cp等二进制文件。同时程序可以长期存在系统中。<br>2.进程是程序运行的过程，是一个动态的概念。进程是存在生命周期的概念的，也就是说进程会随着程序的终止而销毁，不会永久存在系统中。</p>
<h3 id="3-进程的生命周期"><a href="#3-进程的生命周期" class="headerlink" title="3.进程的生命周期"></a>3.进程的生命周期</h3><p>生命周期就是指一个对象的生老病死。用处很广。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghu76tkolgj310w0a20u5.jpg" alt="img"></p>
<p>当父进程接收到任务调度时，会通过fock派生子进程来处理，那么子进程会继承父进程属性。<br>1.子进程在处理任务代码时，父进程会进入等待状态中…<br>2.子进程在处理任务代码后，会执行退出，然后唤醒父进程来回收子进程的资源。<br>3.如果子进程在处理任务过程中，父进程退出了，子进程没有退出，那么这些子进程就没有父进程来管理了，就变成僵尸进程。<br>PS: 每个进程都父进程的PPID，子进程则叫PID。</p>
<p>例: 假设现在我是蒋先生(system进程)….故事持续中…..</p>
<h2 id="2-监控进程状态"><a href="#2-监控进程状态" class="headerlink" title="2.监控进程状态"></a>2.监控进程状态</h2><p>程序在运行后，我们需要了解进程的运行状态。查看进程的状态分为: 静态和动态两种方式</p>
<h3 id="1-使用ps命令查看当前的进程状态-静态"><a href="#1-使用ps命令查看当前的进程状态-静态" class="headerlink" title="1.使用ps命令查看当前的进程状态(静态)"></a>1.使用ps命令查看当前的进程状态(静态)</h3><p>1)示例、ps -aux常用组合，查看进程 用户、PID、占用cpu百分比、占用内存百分比、状态、执行的命令等</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghu770thw2j31gq0p4n8c.jpg" alt="img"></p>
<table>
<thead>
<tr>
<th align="left">状态</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">USER</td>
<td align="left">启动进程的用户</td>
</tr>
<tr>
<td align="left">PID</td>
<td align="left">进程运行的ID号</td>
</tr>
<tr>
<td align="left">%CPU</td>
<td align="left">进程占用CPU百分比</td>
</tr>
<tr>
<td align="left">%MEM</td>
<td align="left">进程占用内存百分比</td>
</tr>
<tr>
<td align="left">VSZ</td>
<td align="left">进程占用虚拟内存大小 (单位KB)</td>
</tr>
<tr>
<td align="left">RSS</td>
<td align="left">进程占用物理内存实际大小 (单位KB)</td>
</tr>
<tr>
<td align="left">TTY</td>
<td align="left">进程是由哪个终端运行启动的tty1、pts&#x2F;0等 ?表示内核程序与终端无关(远程连接会通过tty打开一个bash：tty)</td>
</tr>
<tr>
<td align="left">STAT</td>
<td align="left">进程运行过程中的状态 man ps （&#x2F;STATE）</td>
</tr>
<tr>
<td align="left">START</td>
<td align="left">进程的启动时间</td>
</tr>
<tr>
<td align="left">TIME</td>
<td align="left">进程占用 CPU 的总时间(为0表示还没超过秒)</td>
</tr>
<tr>
<td align="left">COMMAND</td>
<td align="left">程序的运行指令，[ 方括号 ] 属于内核态的进程。 没有 [ ] 的是用户态进程。systemctl status 指令</td>
</tr>
</tbody></table>
<h3 id="2-STAT状态的S、Ss、S-、R、R、S-等等，都是什么意思"><a href="#2-STAT状态的S、Ss、S-、R、R、S-等等，都是什么意思" class="headerlink" title="2.STAT状态的S、Ss、S+、R、R、S+等等，都是什么意思?"></a>2.STAT状态的S、Ss、S+、R、R、S+等等，都是什么意思?</h3><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghu779g9pgj31gq0p4am5.jpg" alt="img"></p>
<table>
<thead>
<tr>
<th align="left">STAT基本状态</th>
<th align="left">描述</th>
<th align="left">STAT状态+符号</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">R</td>
<td align="left">进程运行</td>
<td align="left">s</td>
<td align="left">进程是控制进程， Ss进程的领导者，父进程</td>
</tr>
<tr>
<td align="left">S</td>
<td align="left">可中断睡眠</td>
<td align="left">&lt;</td>
<td align="left">进程运行在高优先级上，S&lt;优先级较高的进程</td>
</tr>
<tr>
<td align="left">T</td>
<td align="left">进程被暂停</td>
<td align="left">N</td>
<td align="left">进程运行在低优先级上，SN优先级较低的进程</td>
</tr>
<tr>
<td align="left">D</td>
<td align="left">不可中断睡眠</td>
<td align="left">+</td>
<td align="left">当前进程运行在前台，R+该表示进程在前台运行（正在io操作，一旦停止，数据丢失）</td>
</tr>
<tr>
<td align="left">Z</td>
<td align="left">僵尸进程</td>
<td align="left">l</td>
<td align="left">进程是多线程的，Sl表示进程是以线程方式运行</td>
</tr>
</tbody></table>
<p>案例一、PS命令查看进程状态切换</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1.在终端1上运行vim</span></span><br><span class="line">[root@lqz ~]<span class="comment"># vim oldboy</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.在终端2上运行ps命令查看状态</span></span><br><span class="line">[root@lqz ~]<span class="comment"># ps aux|grep oldboy    #S表示睡眠模式，+表示前台运行</span></span><br><span class="line">root      58118  0.4  0.2 151788  5320 pts/1    S+   22:11   0:00 oldboy</span><br><span class="line">root      58120  0.0  0.0 112720   996 pts/0    R+   22:12   0:00 grep --color=auto oldboy</span><br><span class="line"><span class="comment">#在终端1上挂起vim命令，按下：ctrl+z </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3.回到终端2再次运行ps命令查看状态</span></span><br><span class="line">[root@lqz ~]<span class="comment"># ps aux|grep oldboy    #T表示停止状态</span></span><br><span class="line">root      58118  0.1  0.2 151788  5320 pts/1    T    22:11   0:00 vim oldboy</span><br><span class="line">root      58125  0.0  0.0 112720   996 pts/0    R+   22:12   0:00 grep --color=auto oldboy</span><br></pre></td></tr></table></figure>

<p>案例二、PS命令查看不可中断状态进程</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1.使用tar打包文件时，可以通过终端不断查看状态，由S+，R+变为D+</span></span><br><span class="line">[root@lqz ~]<span class="comment"># tar -czf etc.tar.gz /etc/ /usr/ /var/</span></span><br><span class="line"></span><br><span class="line">[root@lqz ~]<span class="comment"># ps aux|grep tar|grep -v grep</span></span><br><span class="line">root      58467  5.5  0.2 127924  5456 pts/1    R+   22:22   0:04 tar -czf etc.tar.gz /etc/ </span><br><span class="line">[root@lqz ~]<span class="comment"># ps aux|grep tar|grep -v grep</span></span><br><span class="line">root      58467  5.5  0.2 127088  4708 pts/1    S+   22:22   0:03 tar -czf etc.tar.gz /etc/ </span><br><span class="line">[root@lqz ~]<span class="comment"># ps aux|grep tar|grep -v grep</span></span><br><span class="line">root      58467  5.6  0.2 127232  4708 pts/1    D+   22:22   0:03 tar -czf etc.tar.gz /etc/ </span><br></pre></td></tr></table></figure>

<h3 id="2-使用top命令查看当前的进程状态-动态"><a href="#2-使用top命令查看当前的进程状态-动态" class="headerlink" title="2.使用top命令查看当前的进程状态(动态)"></a>2.使用top命令查看当前的进程状态(动态)</h3><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghu77gow7kj31ea0mcdrs.jpg" alt="img"></p>
<table>
<thead>
<tr>
<th align="left">任务</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Tasks: 129 total</td>
<td align="left">当然进程的总数</td>
</tr>
<tr>
<td align="left">1 running</td>
<td align="left">正在运行的进程数</td>
</tr>
<tr>
<td align="left">128 sleeping</td>
<td align="left">睡眠的进程数</td>
</tr>
<tr>
<td align="left">0 stopped</td>
<td align="left">停止的进程数</td>
</tr>
<tr>
<td align="left">0 zombie</td>
<td align="left">僵尸进程数</td>
</tr>
<tr>
<td align="left">%Cpu(s)</td>
<td align="left">平均cpu使用率，按1 查看每个cup具体状态</td>
</tr>
<tr>
<td align="left">0.7 us</td>
<td align="left">用户进程占用cpu百分比</td>
</tr>
<tr>
<td align="left">0.7 sys</td>
<td align="left">内核进程占用百分比</td>
</tr>
<tr>
<td align="left">0.0 ni</td>
<td align="left">优先级进程占用cpu的百分比</td>
</tr>
<tr>
<td align="left">98.7 id</td>
<td align="left">空闲cup</td>
</tr>
<tr>
<td align="left">0.0 wa</td>
<td align="left">CPU等待IO完成的时间，大量的io等待，会变高</td>
</tr>
<tr>
<td align="left">0.0 hi</td>
<td align="left">硬中断，占的CPU百分比</td>
</tr>
<tr>
<td align="left">0.0 si</td>
<td align="left">软中断，占的CPU百分比</td>
</tr>
<tr>
<td align="left">0.0 st</td>
<td align="left">虚拟机占用物理CPU的时间</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># w     load average:平均负载 一分钟，5分钟，15分钟</span></span><br><span class="line"> 04:05:<span class="number">43</span> up <span class="number">11</span>:<span class="number">35</span>,  <span class="number">3</span> users,  load average: <span class="number">0.00</span>, <span class="number">0.01</span>, <span class="number">0.05</span></span><br><span class="line"><span class="comment"># uptime</span></span><br><span class="line"> 04:06:<span class="number">21</span> up <span class="number">11</span>:<span class="number">35</span>,  <span class="number">3</span> users,  load average: <span class="number">0.00</span>, <span class="number">0.01</span>, <span class="number">0.05</span></span><br></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xuliangwei/p/10789270.html">PS: 如何理解中断这个东西</a></p>
<p>top 常见指令</p>
<table>
<thead>
<tr>
<th align="left">字母</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">h</td>
<td align="left">查看帮出</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">数字1，显示所有CPU核心的负载</td>
</tr>
<tr>
<td align="left">z</td>
<td align="left">以高亮显示数据</td>
</tr>
<tr>
<td align="left">b</td>
<td align="left">高亮显示处于R（进行中）状态的进程</td>
</tr>
<tr>
<td align="left">M</td>
<td align="left">按内存使用百分比排序输出</td>
</tr>
<tr>
<td align="left">P</td>
<td align="left">按CPU使用百分比排序输出</td>
</tr>
<tr>
<td align="left">q</td>
<td align="left">退出top</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第三方top</span></span><br><span class="line">htop，top高级:yum install htop -y</span><br><span class="line">iftop网卡流量:yum install iftop -y</span><br><span class="line">glances，直观的显示:yum install glances -y</span><br><span class="line">  -rz上传文件，可以动态看到,网卡情况</span><br></pre></td></tr></table></figure>



<h2 id="3-管理进程状态"><a href="#3-管理进程状态" class="headerlink" title="3.管理进程状态"></a>3.管理进程状态</h2><p>当程序运行为进程后，如果希望停止进程，怎么办呢? 那么此时我们可以使用linux的kill命令对进程发送关闭信号。当然除了kill、还有killall，pkill</p>
<h3 id="1-使用kill-l列出当前系统所支持的信号"><a href="#1-使用kill-l列出当前系统所支持的信号" class="headerlink" title="1.使用kill -l列出当前系统所支持的信号"></a>1.使用kill -l列出当前系统所支持的信号</h3><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghu77namunj31ea0mcqfj.jpg" alt="img"><br>虽然linux支持信号很多，但是我们仅列出我们最为常用的3个信号</p>
<table>
<thead>
<tr>
<th align="left">数字编号</th>
<th align="left">信号含义</th>
<th align="left">信号翻译</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">SIGHUP</td>
<td align="left">通常用来重新加载配置文件,重新读取一次参数的配置文件 （类似 reload）</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left">SIGKILL</td>
<td align="left">强制杀死进程(有状态的服务(存磁盘的，如mysql)强制停止可能会导致下次起不来)</td>
</tr>
<tr>
<td align="left">15</td>
<td align="left">SIGTERM</td>
<td align="left">终止进程，默认kill使用该信号</td>
</tr>
</tbody></table>
<p>1.我们使用kill命令杀死指定PID的进程。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1.给 vsftpd 进程发送信号 1,15</span></span><br><span class="line">[root@lqz ~]<span class="comment"># yum -y install vsftpd</span></span><br><span class="line">[root@lqz ~]<span class="comment"># systemctl start vsftpd</span></span><br><span class="line">[root@lqz ~]<span class="comment"># ps aux|grep vsftpd</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.发送重载信号，例如 vsftpd 的配置文件发生改变，希望重新加载</span></span><br><span class="line">[root@lqz ~]<span class="comment"># kill -1 9160</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3.发送停止信号，当然vsftpd 服务有停止的脚本 systemctl stop vsftpd</span></span><br><span class="line">[root@lqz ~]<span class="comment"># kill 9160</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#4.发送强制停止信号，当无法停止服务时，可强制终止信号</span></span><br><span class="line">[root@lqz ~]<span class="comment"># kill -9 9160</span></span><br></pre></td></tr></table></figure>

<p>2.Linux系统中的killall、pkill命令用于杀死指定名字的进程。我们可以使用kill命令杀死指定进程PID的进程，如果要找到我们需要杀死的进程，我们还需要在之前使用ps等命令再配合grep来查找进程，而killall、pkill把这两个过程合二为一，是一个很好用的命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#例0、通过服务名称杀掉进程</span></span><br><span class="line">[root@lqz ~]<span class="comment"># vim nginx.conf   # 修改为worker_processes  10;</span></span><br><span class="line">[root@lqz ~]<span class="comment"># kill -1 26093    # 平滑reload nginx,可以看到很多ngixn进程</span></span><br><span class="line">[root@lqz ~]<span class="comment"># kill 26121      # 杀掉一个子进程，会迅速的被master启动起来，只是id号不一致了</span></span><br><span class="line"></span><br><span class="line">[root@lqz ~]<span class="comment"># kill  26093    # 主进程，子进程都会被杀掉 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#例1、通过服务名称杀掉进程</span></span><br><span class="line">[root@lqz ~]<span class="comment"># pkill nginx</span></span><br><span class="line">[root@lqz ~]<span class="comment"># killall nginx</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#例2、使用pkill踢出从远程登录到本机的用户，终止pts/0上所有进程, 并且bash也结束（用户被强制退出）</span></span><br><span class="line">[root@lqz ~]<span class="comment"># pkill -9 bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 一般程序都会有自己的启动和停止</span></span><br><span class="line">/usr/local/nginx/sbin/nginx -h</span><br></pre></td></tr></table></figure>

<h2 id="4-管理后台进程"><a href="#4-管理后台进程" class="headerlink" title="4.管理后台进程"></a>4.管理后台进程</h2><h3 id="1-什么是后台进程"><a href="#1-什么是后台进程" class="headerlink" title="1.什么是后台进程"></a>1.什么是后台进程</h3><p>通常进程都会在终端前台运行，一旦关闭终端，进程也会随着结束，那么此时我们就希望进程能在后台运行，就是将在前台运行的进程放入后台运行，这样及时我们关闭了终端也不影响进程的正常运行。</p>
<h3 id="2-我们为什么要将进程放入后台运行"><a href="#2-我们为什么要将进程放入后台运行" class="headerlink" title="2.我们为什么要将进程放入后台运行"></a>2.我们为什么要将进程放入后台运行</h3><p>比如：我们此前在国内服务器往国外服务器传输大文件时，由于网络的问题需要传输很久，如果在传输的过程中出现网络抖动或者不小心关闭了终端则会导致传输失败，如果能将传输的进程放入后台，是不是就能解决此类问题了。</p>
<h3 id="3-使用什么工具将进程放入后台"><a href="#3-使用什么工具将进程放入后台" class="headerlink" title="3.使用什么工具将进程放入后台"></a>3.使用什么工具将进程放入后台</h3><p>早期的时候大家都选择使用&amp;符号将进程放入后台，然后在使用jobs、bg、fg等方式查看进程状态，但太麻烦了。也不直观，所以我们推荐使用screen。</p>
<p>1.jobs、bg、fg的使用(强烈不推荐，了解即可)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@lqz ~]<span class="comment"># sleep 3000 &amp; //运行程序(时)，让其在后台执行 </span></span><br><span class="line">[root@lqz ~]<span class="comment"># sleep 4000 //^Z,将前台的程序挂起(暂停)到后台 </span></span><br><span class="line">[2]+ Stopped <span class="built_in">sleep</span> 4000</span><br><span class="line">[root@lqz ~]<span class="comment"># ps aux |grep sleep</span></span><br><span class="line">[root@lqz ~]<span class="comment"># jobs  //查看后台作业</span></span><br><span class="line">[1]- Running <span class="built_in">sleep</span> 3000 &amp; </span><br><span class="line">[2]+ Stopped <span class="built_in">sleep</span> 4000</span><br><span class="line"></span><br><span class="line">[root@lqz ~]<span class="comment"># bg %2     //让作业 2 在后台运行</span></span><br><span class="line">[root@lqz ~]<span class="comment"># fg %1     //将作业 1 调回到前台</span></span><br><span class="line">[root@lqz ~]<span class="comment"># kill %1   //kill 1，终止 PID 为 1 的进程</span></span><br><span class="line"></span><br><span class="line">[root@lqz ~]<span class="comment"># (while :; do date; sleep 2; done) &amp; //进程在后台运行，但输出依然在当前终端</span></span><br><span class="line">[root@lqz ~]<span class="comment"># (while :; do date; sleep 2; done) &amp;&gt;/dev/null &amp;</span></span><br></pre></td></tr></table></figure>

<p>2.screen的使用(强烈推荐，生产必用)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1.安装</span></span><br><span class="line">[root@oldboy ~]<span class="comment"># yum install screen -y</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.开启一个screen窗口,指定名称</span></span><br><span class="line">[root@oldboy ~]<span class="comment"># screen -S wget_mysql</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3.在screen窗口中执行任务即可</span></span><br><span class="line">[root@oldboy ~]<span class="comment"># wget https://downloads.mysql.com/archives/get/p/23/file/mysql-5.7.30-linux-glibc2.12-x86_64.tar.gz --no-check-certificate</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#4.平滑的退出screen,但不会终止screen中的任务。注意: 如果使用exit 才算真的关闭screen窗口</span></span><br><span class="line">ctrl+a+d</span><br><span class="line"></span><br><span class="line"><span class="comment">#5.查看当前正在运行的screen有哪些</span></span><br><span class="line">[root@oldboy ~]<span class="comment"># screen -list</span></span><br><span class="line">There is a screen on:</span><br><span class="line">    22058.wget_mysql    (Detached)</span><br><span class="line">1 Socket <span class="keyword">in</span> /var/run/screen/S-root.</span><br><span class="line"></span><br><span class="line"><span class="comment">#6.进入正在运行的screen</span></span><br><span class="line">[root@oldboy ~]<span class="comment"># screen -r wget_mysql</span></span><br><span class="line">[root@oldboy ~]<span class="comment"># screen -r 22058</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#7 终止（ctrl+d），退出才能停止screen</span></span><br><span class="line"><span class="built_in">exit</span>  </span><br></pre></td></tr></table></figure>

<h2 id="5-进程的优先级-进阶"><a href="#5-进程的优先级-进阶" class="headerlink" title="5.进程的优先级[进阶]"></a>5.进程的优先级[进阶]</h2><h3 id="1-什么优先级"><a href="#1-什么优先级" class="headerlink" title="1.什么优先级"></a>1.什么优先级</h3><p>优先级指的是优先享受资源，比如排队买票时，军人优先、老人优先。等等</p>
<h3 id="2-为什么要有系统优先级"><a href="#2-为什么要有系统优先级" class="headerlink" title="2.为什么要有系统优先级"></a>2.为什么要有系统优先级</h3><p>举个例子: 海底捞火锅正常情况下响应就特别快，那么当节假日来临时人员突增则会导致处理请求特别慢，那么假设我是海底捞VIP客户(最高优先级)，无论门店多么繁忙，我都不用排队，海底捞人员会直接服务于我，满足我的需求。至于没有VIP的人员(较低优先级)则进入排队等待状态。(PS: 至于等多久，那…..)</p>
<h3 id="3-系统中如何给进程配置优先级"><a href="#3-系统中如何给进程配置优先级" class="headerlink" title="3.系统中如何给进程配置优先级?"></a>3.系统中如何给进程配置优先级?</h3><p>在启动进程时，为不同的进程使用不同的调度策略。<br>nice 值越高： 表示优先级越低，例如+19，该进程容易将CPU 使用量让给其他进程。<br>nice 值越低： 表示优先级越高，例如-20，该进程更不倾向于让出CPU。</p>
<ol>
<li>使用top或ps命令查看进程的优先级</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1.使用top可以查看nice优先级。  </span></span><br><span class="line">NI: 实际<span class="built_in">nice</span>级别，默认是0。 </span><br><span class="line">PR: 显示<span class="built_in">nice</span>值，-20映射到0，+19映射到39</span><br><span class="line"></span><br><span class="line">PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND</span><br><span class="line">1083 root      20   0  298628   2808   1544 S  0.3  0.1   2:49.28 vmtoolsd</span><br><span class="line">5    root       0 -20       0      0      0 S  0.0  0.0   0:00.00 kworker/0:+</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.使用ps查看进程优先级</span></span><br><span class="line">[root@m01 ~]<span class="comment"># ps axo command,nice |grep sshd|grep -v grep</span></span><br><span class="line">/usr/sbin/sshd -D             0</span><br><span class="line">sshd: root@pts/2              0</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>nice指定程序的优先级。语法格式 nice -n 优先级数字 进程名称</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1.开启vim并且指定程序优先级为-5</span></span><br><span class="line">[root@m01 ~]<span class="comment"># nice -n -5 vim &amp;</span></span><br><span class="line">[1] 98417</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.查看该进程的优先级情况</span></span><br><span class="line">[root@m01 ~]<span class="comment"># ps axo pid,command,nice |grep 98417</span></span><br><span class="line"> 98417 vim                         -5</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>renice命令修改一个正在运行的进程优先级。语法格式 renice -n 优先级数字 进程pid</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1.查看sshd进程当前的优先级状态</span></span><br><span class="line">[root@m01 ~]<span class="comment"># ps axo pid,command,nice |grep 折叠shd</span></span><br><span class="line"> 70840 sshd: root@pts/2              0</span><br><span class="line"> 98002 /usr/sbin/sshd -D             0</span><br><span class="line"> </span><br><span class="line"><span class="comment">#2.调整sshd主进程的优先级</span></span><br><span class="line">[root@m01 ~]<span class="comment"># renice -n -20 98002</span></span><br><span class="line">98002 (process ID) old priority 0, new priority -20</span><br><span class="line"></span><br><span class="line"><span class="comment">#3.调整之后记得退出终端</span></span><br><span class="line">[root@m01 ~]<span class="comment"># ps axo pid,command,nice |grep 折叠shd</span></span><br><span class="line"> 70840 sshd: root@pts/2              0</span><br><span class="line"> 98002 /usr/sbin/sshd -D           -20</span><br><span class="line">[root@m01 ~]<span class="comment"># exit</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#4.当再次登陆sshd服务，会由主进程fork子进程(那么子进程会继承主进程的优先级)</span></span><br><span class="line">[root@m01 ~]<span class="comment"># ps axo pid,command,nice |grep 折叠shd</span></span><br><span class="line"> 98002 /usr/sbin/sshd -D           -20</span><br><span class="line"> 98122 sshd: root@pts/0            -20</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://www.xuliangwei.com/bgx/1337.html">生产案例、Linux出现假死，怎么办，又如何通过nice解决？</a></p>
<h2 id="6-系统平均负载-进阶"><a href="#6-系统平均负载-进阶" class="headerlink" title="6.系统平均负载[进阶]"></a>6.系统平均负载[进阶]</h2><p>每次发现系统变慢时，我们通常做的第一件事，就是执行 top 或者 uptime 命令，来了解系统的负载情况。比如像下面这样，我在命令行里输入了 uptime 命令，系统也随即给出了结果。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@m01 ~]<span class="comment"># uptime</span></span><br><span class="line"> 04:49:26 up 2 days,  2:33,  2 <span class="built_in">users</span>,  load average: 0.70, 0.04, 0.05</span><br><span class="line"><span class="comment">#我们已经比较熟悉前面几列，它们分别是当前时间、系统运行时间以及正在登录用户数。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 而最后三个数字呢，依次则是过去 1 分钟、5 分钟、15 分钟的平均负载（Load Average）。</span></span><br></pre></td></tr></table></figure>

<h3 id="1-什么是平均负载"><a href="#1-什么是平均负载" class="headerlink" title="1.什么是平均负载"></a>1.什么是平均负载</h3><p>平均负载不就是单位时间内的 CPU 使用率吗？上面的 0.70，就代表 CPU 使用率是 70%。其实上并…..<br>那到底如何理解平均负载: 平均负载是指单位时间内，系统处于可运行状态和不可中断状态的平均进程数，也就是平均活跃进程数， PS: 平均负载与 CPU 使用率并没有直接关系。</p>
<h3 id="2-可运行状态和不可中断状态是什么"><a href="#2-可运行状态和不可中断状态是什么" class="headerlink" title="2.可运行状态和不可中断状态是什么"></a>2.可运行状态和不可中断状态是什么</h3><p>1.可运行状态进程，是指正在使用 CPU 或者正在等待 CPU 的进程，也就是我们ps 命令看到处于 R 状态的进程。<br>2.不可中断进程，(你做什么事情的时候是不能打断的?) 系统中最常见的是等待硬件设备的 I&#x2F;O 响应，也就是我们 ps 命令中看到的 D 状态（也称为 Disk Sleep）的进程。<br>例如: 当一个进程向磁盘读写数据时，为了保证数据的一致性，在得到磁盘回复前，它是不能被其他进程或者中断打断的，这个时候的进程就处于不可中断状态。如果此时的进程被打断了，就容易出现磁盘数据与进程数据不一致的问题。所以，不可中断状态实际上是系统对进程和硬件设备的一种保护机制。</p>
<p>划重点，因此你可以简单理解为，平均负载其实就是单位时间内的活跃进程数。</p>
<h3 id="3-那平均负载为多少时合理"><a href="#3-那平均负载为多少时合理" class="headerlink" title="3.那平均负载为多少时合理"></a>3.那平均负载为多少时合理</h3><p>最理想的状态是每个 CPU 上都刚好运行着一个进程，这样每个 CPU 都得到了充分利用。所以在评判平均负载时，首先你要知道系统有几个 CPU，这可以通过 top 命令获取，或<code>grep &#39;model name&#39; /proc/cpuinfo</code></p>
<p>例1、假设现在在 4、2、1核的CPU上，如果平均负载为 2 时，意味着什么呢？<br>Q1.在4 个 CPU 的系统上，意味着 CPU 有 50% 的空闲。<br>Q2.在2 个 CPU 的系统上，意味着所有的 CPU 都刚好被完全占用。<br>Q3.而1 个 CPU 的系统上，则意味着有一半的进程竞争不到 CPU。</p>
<p>PS: 平均负载有三个数值，我们应该关注哪个呢?<br>实际上，我们都需要关注。就好比上海4月的天气，如果只看晚上天气，感觉在过冬天呢。但如果你结合了早上、中午、晚上三个时间点的温度来看，基本就可以全方位了解这一天的天气情况了。</p>
<p>1.如果 1 分钟、5 分钟、15 分钟的三个值基本相同，或者相差不大，那就说明系统负载很平稳。<br>2.但如果 1 分钟的值远小于 15 分钟的值，就说明系统最近 1 分钟的负载在减少，而过去 15 分钟内却有很大的负载。<br>3.反过来，如果 1 分钟的值远大于 15 分钟的值，就说明最近 1 分钟的负载在增加，这种增加有可能只是临时性的，也有可能还会持续上升，所以就需要持续观察。<br>PS: 一旦 1 分钟的平均负载接近或超过了 CPU 的个数，就意味着系统正在发生过载的问题，这时就得分析问题，并要想办法优化了</p>
<p>在来看个例子3、假设我们在有2个 CPU 系统上看到平均负载为 2.73，6.90，12.98<br>那么说明在过去1 分钟内，系统有 136% 的超载 (2.73&#x2F;2&#x3D;136%)<br>而在过去 5 分钟内，有 345% 的超载 (6.90&#x2F;2&#x3D;345%)<br>而在过去15 分钟内，有 649% 的超载，(12.98&#x2F;2&#x3D;649%)<br>但从整体趋势来看，系统的负载是在逐步的降低。</p>
<h3 id="4-那么在实际生产环境中，平均负载多高时，需要我们重点关注呢？"><a href="#4-那么在实际生产环境中，平均负载多高时，需要我们重点关注呢？" class="headerlink" title="4.那么在实际生产环境中，平均负载多高时，需要我们重点关注呢？"></a>4.那么在实际生产环境中，平均负载多高时，需要我们重点关注呢？</h3><p>当平均负载高于 CPU 数量 70% 的时候，你就应该分析排查负载高的问题了。一旦负载过高，就可能导致进程响应变慢，进而影响服务的正常功能。<br>但 70% 这个数字并不是绝对的，最推荐的方法，还是把系统的平均负载监控起来，然后根据更多的历史数据，判断负载的变化趋势。当发现负载有明显升高趋势时，比如说负载翻倍了，你再去做分析和调查。</p>
<h3 id="5-平均负载与-CPU-使用率有什么关系"><a href="#5-平均负载与-CPU-使用率有什么关系" class="headerlink" title="5.平均负载与 CPU 使用率有什么关系"></a>5.平均负载与 CPU 使用率有什么关系</h3><p>在实际工作中，我们经常容易把平均负载和 CPU 使用率混淆，所以在这里，我也做一个区分。可能你会疑惑，既然平均负载代表的是活跃进程数，那平均负载高了，不就意味着 CPU 使用率高吗？<br>我们还是要回到平均负载的含义上来，平均负载是指单位时间内，处于可运行状态和不可中断状态的进程数。所以，它不仅包括了正在使用 CPU 的进程，还包括等待 CPU 和等待 I&#x2F;O 的进程。</p>
<p>而 CPU 使用率，是单位时间内 CPU 繁忙情况的统计，跟平均负载并不一定完全对应。比如：<br>CPU 密集型进程，使用大量 CPU 会导致平均负载升高，此时这两者是一致的；<br>I&#x2F;O 密集型进程，等待 I&#x2F;O 也会导致平均负载升高，但 CPU 使用率不一定很高；<br>大量等待 CPU 的进程调度也会导致平均负载升高，此时的 CPU 使用率也会比较高。</p>
<h3 id="6-平均负载案例分析实战"><a href="#6-平均负载案例分析实战" class="headerlink" title="6.平均负载案例分析实战"></a>6.平均负载案例分析实战</h3><p>下面，我们以三个示例分别来看这三种情况，并用 stress、mpstat、pidstat 等工具，找出平均负载升高的根源。<br>stress 是 Linux 系统压力测试工具，这里我们用作异常进程模拟平均负载升高的场景。<br>mpstat 是多核 CPU 性能分析工具，用来实时查看每个 CPU 的性能指标，以及所有 CPU 的平均指标。<br>pidstat 是一个常用的进程性能分析工具，用来实时查看进程的 CPU、内存、I&#x2F;O 以及上下文切换等性能指标。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#如果出现无法使用mpstat、pidstat命令查看%wait指标建议更新下软件包</span></span><br><span class="line">wget http://pagesperso-orange.fr/sebastien.godard/sysstat-11.7.3-1.x86_64.rpm</span><br><span class="line">rpm -Uvh sysstat-11.7.3-1.x86_64.rpm</span><br></pre></td></tr></table></figure>

<p>场景一：CPU 密集型进程</p>
<p>1.首先，我们在第一个终端运行 stress 命令，模拟一个 CPU 使用率 100% 的场景：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@m01 ~]<span class="comment"># stress --cpu 1 --timeout 600</span></span><br></pre></td></tr></table></figure>

<p>2.接着，在第二个终端运行 uptime 查看平均负载的变化情况</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用watch -d 参数表示高亮显示变化的区域(注意负载会持续升高)</span></span><br><span class="line">[root@m01 ~]<span class="comment"># watch -d uptime</span></span><br><span class="line">17:27:44 up 2 days,  3:11,  3 <span class="built_in">users</span>,  load average: 1.10, 0.30, 0.17</span><br></pre></td></tr></table></figure>

<p>3.最后，在第三个终端运行 mpstat 查看 CPU 使用率的变化情况</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -P ALL 表示监控所有 CPU，后面数字 5 表示间隔 5 秒后输出一组数据</span></span><br><span class="line">[root@m01 ~]<span class="comment"># mpstat -P ALL 5</span></span><br><span class="line">Linux 3.10.0-957.1.3.el7.x86_64 (m01)   2019年04月29日     _x86_64_    (1 CPU)</span><br><span class="line"></span><br><span class="line">17时32分03秒  CPU    %usr   %<span class="built_in">nice</span>    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle</span><br><span class="line">17时32分08秒  all   99.80    0.00    0.20    0.00    0.00    0.00    0.00    0.00    0.00    0.00</span><br><span class="line">17时32分08秒    0   99.80    0.00    0.20    0.00    0.00    0.00    0.00    0.00    0.00    0.00</span><br><span class="line"></span><br><span class="line"><span class="comment">#单核CPU所以只有一个all和0</span></span><br></pre></td></tr></table></figure>

<p>4.从终端二中可以看到，1 分钟的平均负载会慢慢增加到 1.00，而从终端三中还可以看到，正好有一个 CPU 的使用率为 100%，但它的 iowait 只有 0。这说明，平均负载的升高正是由于 CPU 使用率为 100% 。那么，到底是哪个进程导致了 CPU 使用率为 100% 呢？可以使用 pidstat 来查询</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 间隔 5 秒后输出一组数据</span></span><br><span class="line">[root@m01 ~]<span class="comment"># pidstat -u 5 1</span></span><br><span class="line">Linux 3.10.0-957.1.3.el7.x86_64 (m01)   2019年04月29日     _x86_64_(1 CPU)</span><br><span class="line"></span><br><span class="line">17时33分21秒   UID       PID    %usr %system  %guest    %CPU   CPU  Command</span><br><span class="line">17时33分26秒     0    110019   98.80    0.00    0.00   98.80     0  stress</span><br><span class="line"></span><br><span class="line"><span class="comment">#从这里可以明显看到，stress 进程的 CPU 使用率为 100%。</span></span><br></pre></td></tr></table></figure>

<p>场景二：I&#x2F;O 密集型进程</p>
<p>1.首先还是运行 stress 命令，但这次模拟 I&#x2F;O 压力，即不停地执行 sync</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@m01 ~]<span class="comment"># stress  --io 1 --timeout 600s</span></span><br></pre></td></tr></table></figure>

<p>2.然后在第二个终端运行 uptime 查看平均负载的变化情况：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@m01 ~]<span class="comment"># watch -d uptime</span></span><br><span class="line">18:43:51 up 2 days,  4:27,  3 <span class="built_in">users</span>,  load average: 1.12, 0.65, 0.00</span><br></pre></td></tr></table></figure>

<p>3.最后第三个终端运行 mpstat 查看 CPU 使用率的变化情况：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示所有 CPU 的指标，并在间隔 5 秒输出一组数据</span></span><br><span class="line">[root@m01 ~]<span class="comment"># mpstat -P ALL 5</span></span><br><span class="line">Linux 3.10.0-693.2.2.el7.x86_64 (bgx.com)   2019年05月07日     _x86_64_    (1 CPU)</span><br><span class="line"></span><br><span class="line">14时20分07秒  CPU    %usr   %<span class="built_in">nice</span>    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle</span><br><span class="line">14时20分12秒  all    0.20    0.00   82.45   17.35    0.00    0.00    0.00    0.00    0.00    0.00</span><br><span class="line">14时20分12秒    0    0.20    0.00   82.45   17.35    0.00    0.00    0.00    0.00    0.00    0.00</span><br><span class="line"></span><br><span class="line"><span class="comment">#会发现cpu的与内核打交道的sys占用非常高</span></span><br></pre></td></tr></table></figure>

<p>4.那么到底是哪个进程，导致 iowait 这么高呢？我们还是用 pidstat 来查询</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 间隔 5 秒后输出一组数据，-u 表示 CPU 指标</span></span><br><span class="line">[root@m01 ~]<span class="comment"># pidstat -u 5 1</span></span><br><span class="line">Linux 3.10.0-957.1.3.el7.x86_64 (m01)   2019年04月29日     _x86_64_(1 CPU)</span><br><span class="line">18时29分37秒   UID       PID    %usr %system  %guest   %<span class="built_in">wait</span>    %CPU   CPU  Command</span><br><span class="line">18时29分42秒     0    127259   32.60    0.20    0.00   67.20   32.80     0  stress</span><br><span class="line">18时29分42秒     0    127261    4.60   28.20    0.00   67.20   32.80     0  stress</span><br><span class="line">18时29分42秒     0    127262    4.20   28.60    0.00   67.20   32.80     0  stress</span><br><span class="line"></span><br><span class="line"><span class="comment">#可以发现，还是 stress 进程导致的。</span></span><br></pre></td></tr></table></figure>

<p>场景三：大量进程的场景<br>当系统中运行进程超出 CPU 运行能力时，就会出现等待 CPU 的进程。</p>
<p>1.首先，我们还是使用 stress，但这次模拟的是 4 个进程</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@m01 ~]<span class="comment"># stress -c 4 --timeout 600</span></span><br></pre></td></tr></table></figure>

<p>2.由于系统只有 1 个 CPU，明显比 4 个进程要少得多，因而，系统的 CPU 处于严重过载状态</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@m01 ~]<span class="comment"># watch -d uptime</span></span><br><span class="line">19:11:07 up 2 days,  4:45,  3 <span class="built_in">users</span>,  load average: 4.65, 2.65, 4.65</span><br></pre></td></tr></table></figure>

<p>3.然后，再运行 pidstat 来看一下进程的情况：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 间隔 5 秒后输出一组数据</span></span><br><span class="line">[root@m01 ~]<span class="comment"># pidstat -u 5 1</span></span><br><span class="line">平均时间:   UID       PID    %usr %system  %guest   %<span class="built_in">wait</span>    %CPU   CPU  Command</span><br><span class="line">平均时间:     0    130290   24.55    0.00    0.00   75.25   24.55     -  stress</span><br><span class="line">平均时间:     0    130291   24.95    0.00    0.00   75.25   24.95     -  stress</span><br><span class="line">平均时间:     0    130292   24.95    0.00    0.00   75.25   24.95     -  stress</span><br><span class="line">平均时间:     0    130293   24.75    0.00    0.00   74.65   24.75     -  stress</span><br></pre></td></tr></table></figure>

<p>可以看出，4 个进程在争抢 1 个 CPU，每个进程等待 CPU 的时间（也就是代码块中的 %wait 列）高达 75%。这些超出 CPU 计算能力的进程，最终导致 CPU 过载。</p>
<p>分析完这三个案例，我再来归纳一下平均负载与CPU<br>平均负载提供了一个快速查看系统整体性能的手段，反映了整体的负载情况。但只看平均负载本身，我们并不能直接发现，到底是哪里出现了瓶颈。所以，在理解平均负载时，也要注意：<br>平均负载高有可能是 CPU 密集型进程导致的；<br>平均负载高并不一定代表 CPU 使用率高，还有可能是 I&#x2F;O 更繁忙了；<br>当发现负载高的时候，你可以使用 mpstat、pidstat 等工具，辅助分析负载的来源</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/muahao/p/6346775.html">stress工具使用参考</a></p>
</section>
    <!-- Tags START -->
    
      <div class="tags">
        <span>Tags:</span>
        
  <a href="/tags#Linux" >
    <span class="tag-code">Linux</span>
  </a>

      </div>
    
    <!-- Tags END -->
    <!-- NAV START -->
    
  <div class="nav-container">
    <!-- reverse left and right to put prev and next in a more logic postition -->
    
      <a class="nav-left" href="/2020/04/06/linux/%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/16-Linux%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/">
        <span class="nav-arrow">← </span>
        
          16-linux的系统服务介绍
        
      </a>
    
    
      <a class="nav-right" href="/2020/04/06/linux/%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/14-Linux%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/">
        
          14-linux的磁盘管理介绍
        
        <span class="nav-arrow"> →</span>
      </a>
    
  </div>

    <!-- NAV END -->
    <!-- 打赏 START -->
    
      <div class="money-like">
        <div class="reward-btn">
          赏
          <span class="money-code">
            <span class="alipay-code">
              <div class="code-image"></div>
              <b>使用支付宝打赏</b>
            </span>
            <span class="wechat-code">
              <div class="code-image"></div>
              <b>使用微信打赏</b>
            </span>
          </span>
        </div>
        <p class="notice">点击上方按钮,请我喝杯咖啡！</p>
      </div>
    
    <!-- 打赏 END -->
    <!-- 二维码 START -->
    
      <div class="qrcode">
        <canvas id="share-qrcode"></canvas>
        <p class="notice">扫描二维码，分享此文章</p>
      </div>
    
    <!-- 二维码 END -->
    
      <!-- Gitment START -->
      <div id="comments"></div>
      <!-- Gitment END -->
    
  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
    <aside class="catalog-container">
  <div class="toc-main">
  <!-- 不蒜子统计 -->
    <strong class="toc-title">目录</strong>
    
      <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#1-%E4%BB%8B%E7%BB%8D"><span class="toc-nav-text">1.介绍</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%9B%E7%A8%8B"><span class="toc-nav-text">1.什么是进程</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-%E7%A8%8B%E5%BA%8F%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-nav-text">2.程序和进程的区别</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-nav-text">3.进程的生命周期</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#2-%E7%9B%91%E6%8E%A7%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="toc-nav-text">2.监控进程状态</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-%E4%BD%BF%E7%94%A8ps%E5%91%BD%E4%BB%A4%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8D%E7%9A%84%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81-%E9%9D%99%E6%80%81"><span class="toc-nav-text">1.使用ps命令查看当前的进程状态(静态)</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-STAT%E7%8A%B6%E6%80%81%E7%9A%84S%E3%80%81Ss%E3%80%81S-%E3%80%81R%E3%80%81R%E3%80%81S-%E7%AD%89%E7%AD%89%EF%BC%8C%E9%83%BD%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D"><span class="toc-nav-text">2.STAT状态的S、Ss、S+、R、R、S+等等，都是什么意思?</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-%E4%BD%BF%E7%94%A8top%E5%91%BD%E4%BB%A4%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8D%E7%9A%84%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81-%E5%8A%A8%E6%80%81"><span class="toc-nav-text">2.使用top命令查看当前的进程状态(动态)</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#3-%E7%AE%A1%E7%90%86%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="toc-nav-text">3.管理进程状态</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-%E4%BD%BF%E7%94%A8kill-l%E5%88%97%E5%87%BA%E5%BD%93%E5%89%8D%E7%B3%BB%E7%BB%9F%E6%89%80%E6%94%AF%E6%8C%81%E7%9A%84%E4%BF%A1%E5%8F%B7"><span class="toc-nav-text">1.使用kill -l列出当前系统所支持的信号</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#4-%E7%AE%A1%E7%90%86%E5%90%8E%E5%8F%B0%E8%BF%9B%E7%A8%8B"><span class="toc-nav-text">4.管理后台进程</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%90%8E%E5%8F%B0%E8%BF%9B%E7%A8%8B"><span class="toc-nav-text">1.什么是后台进程</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-%E6%88%91%E4%BB%AC%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%B0%86%E8%BF%9B%E7%A8%8B%E6%94%BE%E5%85%A5%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C"><span class="toc-nav-text">2.我们为什么要将进程放入后台运行</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-%E4%BD%BF%E7%94%A8%E4%BB%80%E4%B9%88%E5%B7%A5%E5%85%B7%E5%B0%86%E8%BF%9B%E7%A8%8B%E6%94%BE%E5%85%A5%E5%90%8E%E5%8F%B0"><span class="toc-nav-text">3.使用什么工具将进程放入后台</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#5-%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7-%E8%BF%9B%E9%98%B6"><span class="toc-nav-text">5.进程的优先级[进阶]</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-%E4%BB%80%E4%B9%88%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-nav-text">1.什么优先级</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-nav-text">2.为什么要有系统优先级</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%A6%82%E4%BD%95%E7%BB%99%E8%BF%9B%E7%A8%8B%E9%85%8D%E7%BD%AE%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-nav-text">3.系统中如何给进程配置优先级?</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#6-%E7%B3%BB%E7%BB%9F%E5%B9%B3%E5%9D%87%E8%B4%9F%E8%BD%BD-%E8%BF%9B%E9%98%B6"><span class="toc-nav-text">6.系统平均负载[进阶]</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%B9%B3%E5%9D%87%E8%B4%9F%E8%BD%BD"><span class="toc-nav-text">1.什么是平均负载</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-%E5%8F%AF%E8%BF%90%E8%A1%8C%E7%8A%B6%E6%80%81%E5%92%8C%E4%B8%8D%E5%8F%AF%E4%B8%AD%E6%96%AD%E7%8A%B6%E6%80%81%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-nav-text">2.可运行状态和不可中断状态是什么</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-%E9%82%A3%E5%B9%B3%E5%9D%87%E8%B4%9F%E8%BD%BD%E4%B8%BA%E5%A4%9A%E5%B0%91%E6%97%B6%E5%90%88%E7%90%86"><span class="toc-nav-text">3.那平均负载为多少时合理</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#4-%E9%82%A3%E4%B9%88%E5%9C%A8%E5%AE%9E%E9%99%85%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E4%B8%AD%EF%BC%8C%E5%B9%B3%E5%9D%87%E8%B4%9F%E8%BD%BD%E5%A4%9A%E9%AB%98%E6%97%B6%EF%BC%8C%E9%9C%80%E8%A6%81%E6%88%91%E4%BB%AC%E9%87%8D%E7%82%B9%E5%85%B3%E6%B3%A8%E5%91%A2%EF%BC%9F"><span class="toc-nav-text">4.那么在实际生产环境中，平均负载多高时，需要我们重点关注呢？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#5-%E5%B9%B3%E5%9D%87%E8%B4%9F%E8%BD%BD%E4%B8%8E-CPU-%E4%BD%BF%E7%94%A8%E7%8E%87%E6%9C%89%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB"><span class="toc-nav-text">5.平均负载与 CPU 使用率有什么关系</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#6-%E5%B9%B3%E5%9D%87%E8%B4%9F%E8%BD%BD%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98"><span class="toc-nav-text">6.平均负载案例分析实战</span></a></li></ol></li></ol>
    
  </div>
</aside>
  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'https://mr-lee-alex.github.io/2020/04/06/linux/入门到精通/15-Linux进程管理/';
    var banner = ''
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

    // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', 'http://file.muyutech.com/error-img.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== 'http://file.muyutech.com/error-img.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()

        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })
  })();
</script>


  <script>
    var qr = new QRious({
      element: document.getElementById('share-qrcode'),
      value: document.location.href
    });
  </script>



  <script>
    var gitmentConfig = "";
    if (gitmentConfig !== 'undefined') {
      var gitment = new Gitment({
        id: "15-linux的进程管理介绍",
        owner: "",
        repo: "",
        oauth: {
          client_id: "",
          client_secret: ""
        },
        theme: {
          render(state, instance) {
            const container = document.createElement('div')
            container.lang = "en-US"
            container.className = 'gitment-container gitment-root-container'
            container.appendChild(instance.renderHeader(state, instance))
            container.appendChild(instance.renderEditor(state, instance))
            container.appendChild(instance.renderComments(state, instance))
            container.appendChild(instance.renderFooter(state, instance))
            return container;
          }
        }
      })
      gitment.render(document.getElementById('comments'))
    }
  </script>




    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
<!-- 不蒜子统计 -->
<span id="busuanzi_container_site_pv">
     本站总访问量<span id="busuanzi_value_site_pv"></span>次
</span>
<span class="post-meta-divider">|</span>
<span id="busuanzi_container_site_uv" style='display:none'>
     本站访客数<span id="busuanzi_value_site_uv"></span>人
</span>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



  <p class="copyright">
    &copy; 2022 | Proudly powered by <a href="https://www.cnblogs.com/m-r-lee" target="_blank">李健博的博客园</a>
    <br>
    Theme by <a target="_blank" rel="noopener" href="https://www.cnblogs.com/m-r-lee">李健博的博客园</a>
  </p>
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'true';
  async("//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine === 'false') {
        figure.find('.gutter').hide();
      }
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>





<!-- Baidu Tongji -->


<script src="/js/script.js"></script>


<script src="/js/search.js"></script>


<script src="/js/load.js"></script>



  <span class="local-search local-search-google local-search-plugin" style="right: 50px;top: 70px;;position:absolute;z-index:2;">
      <input type="search" placeholder="站内搜索" id="local-search-input" class="local-search-input-cls" style="">
      <div id="local-search-result" class="local-search-result-cls"></div>
  </span>


  </body>
</html>